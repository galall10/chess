import pygame
import chess
import chess.svg
import io
import random
import chess.engine

# Constants for the GUI
SCREEN_WIDTH = 640
SCREEN_HEIGHT = 640
BOARD_SIZE = min(SCREEN_WIDTH, SCREEN_HEIGHT)
SQUARE_SIZE = BOARD_SIZE // 8
FPS = 60

# Initialize Pygame
pygame.init()
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
clock = pygame.time.Clock()

# Load the chess pieces images
pieces_images = {}
pieces_images['white'] = {}
pieces_images['black'] = {}

for piece_type in ['r', 'n', 'b', 'q', 'k', 'p']:
    pieces_images['white'][piece_type] = pygame.image.load(f'pieces/white_{piece_type}.png')
    pieces_images['black'][piece_type] = pygame.image.load(f'pieces/black_{piece_type}.png')

# Function to draw the chessboard and pieces
def draw_board(board):
    for row in range(8):
        for col in range(8):
            square_color = (255, 206, 158) if (row + col) % 2 == 0 else (209, 139, 71)
            pygame.draw.rect(screen, square_color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
            piece = board.piece_at(8 * row + col)
            if piece:
                piece_color = 'white' if piece.color == chess.WHITE else 'black'
                piece_image = pieces_images[piece_color][piece.symbol().lower()]
                piece_rect = piece_image.get_rect(center=(col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2))
                screen.blit(piece_image, piece_rect)

# Heuristic evaluation function
def evaluate_board(board):
    # Count the total number of pieces each player has
    w_pawns = len(board.pieces(chess.PAWN, chess.WHITE))
    b_pawns = len(board.pieces(chess.PAWN, chess.BLACK))
    w_knights = len(board.pieces(chess.KNIGHT, chess.WHITE))
    b_knights = len(board.pieces(chess.KNIGHT, chess.BLACK))
    w_bishops = len(board.pieces(chess.BISHOP, chess.WHITE))
    b_bishops = len(board.pieces(chess.BISHOP, chess.BLACK))
    w_rooks = len(board.pieces(chess.ROOK, chess.WHITE))
    b_rooks = len(board.pieces(chess.ROOK, chess.BLACK))
    w_queens = len(board.pieces(chess.QUEEN, chess.WHITE))
    b_queens = len(board.pieces(chess.QUEEN, chess.BLACK))

    # Calculate the material score for each player
    w_material = 1 * w_pawns + 3 * w_knights + 3 * w_bishops + 5 * w_rooks + 9 * w_queens
    b_material = 1 * b_pawns + 3 * b_knights + 3 * b_bishops + 5 * b_rooks + 9 * b_queens

    # Return the difference in material score as the heuristic evaluation
    return w_material - b_material

# Minimax algorithm with alpha-beta pruning
def minimax(board, depth, alpha, beta, max_player):
    if depth == 0 or board.is_game_over():
        return evaluate_board(board)

    if max_player:
        max_eval = float('-inf')
        for move in board.legal_moves:
            board.push(move)
            eval = minimax(board, depth - 1, alpha, beta, False)
            board.pop()
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for move in board.legal_moves:
            board.push(move)
            eval = minimax(board, depth - 1, alpha, beta, True)
            board.pop()
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break
        return min_eval

# AI agent function that chooses the best move using the minimax algorithm with alpha-beta pruning
def ai_move(board, difficulty):
    if difficulty == "easy":
        depth = 2
    elif difficulty == "medium":
        depth = 3
    elif difficulty == "hard":
        depth = 4
    else:
        depth = 3  # default to medium difficulty
    best_score = float('-inf')
    best_move = None
    for move in board.legal_moves:
        board.push(move)
        eval = minimax(board, depth - 1, float('-inf'), float('inf'), False)
        board.pop()
        if eval > best_score:
            best_score = eval
            best_move = move
    return best_move

# Human vs AI game loop
def play_game():
    board = chess.Board()
    difficulty = input("Select difficulty level (easy/medium/hard): ")
    engine = chess.engine.SimpleEngine.popen_uci("D:\\Work\\Third Year\\Second Term\\Artifical Intiligence\\stockfish_15.1_win_x64\\stockfish-windows-2022-x86-64.exe"")

    while difficulty not in ["easy", "medium", "hard"]:
        difficulty = input("Invalid difficulty level. Select difficulty level (easy/medium/hard): ")

    # Game loop
    game_over = False
    while not game_over:
        # Handle events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_over = True  # Exit the game loop when the close button is pressed
            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                game_over = True  # Exit the game loop when the ESC key is pressed

        # Update game state
        if not board.is_game_over():
            if board.turn == chess.WHITE:
                result = engine.play(board, chess.engine.Limit(time=1))
                board.push(result.move)
            else:
                move = ai_move(board, difficulty)
                board.push(move)
                print("AI plays:", move.uci())

        # Draw the game board
        print(board)
        draw_board(board)
        pygame.display.update()

    # Game over
    print(board.result())
    engine.quit()
    pygame.quit()

# Start the game
play_game()
